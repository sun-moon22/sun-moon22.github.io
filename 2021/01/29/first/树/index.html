<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>树 | SunMoon Space</title><meta name="keywords" content="Fly"><meta name="author" content="Sun Moon"><meta name="copyright" content="Sun Moon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="树相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="树">
<meta property="og:url" content="http://example.com/2021/01/29/first/%E6%A0%91/index.html">
<meta property="og:site_name" content="SunMoon Space">
<meta property="og:description" content="树相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/img-1608044174071f30505aaa23169cd5ccfb2a0cd4e1798.jpg">
<meta property="article:published_time" content="2021-01-28T16:37:00.000Z">
<meta property="article:modified_time" content="2022-04-21T15:14:50.950Z">
<meta property="article:author" content="Sun Moon">
<meta property="article:tag" content="Fly">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/img-1608044174071f30505aaa23169cd5ccfb2a0cd4e1798.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/01/29/first/%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Sun Moon","link":"链接: ","source":"来源: SunMoon Space","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-21 23:14:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/aplayer/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/img-1608044174071f30505aaa23169cd5ccfb2a0cd4e1798.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">SunMoon Space</a><div id="he-plugin-simple"></div></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/aplayer/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-28T16:37:00.000Z" title="发表于 2021-01-29 00:37:00">2021-01-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-21T15:14:50.950Z" title="更新于 2022-04-21 23:14:50">2022-04-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="/2021/01/29/first/%E6%A0%91/image-20210830153050866.png" alt="image-20210830153050866"></p>
<h1 id="一、二叉树入门"><a href="#一、二叉树入门" class="headerlink" title="一、二叉树入门"></a>一、二叉树入门</h1><p>对于链表其增加删的效率较高，但是查询的效率比较低，为了在保证增删效率的同时，提高查询效率，学习树这种<strong>数据结构</strong></p>
<h2 id="1-1树定义"><a href="#1-1树定义" class="headerlink" title="1.1树定义"></a>1.1树定义</h2><p>由n（n&gt;&#x3D;1）个有限节点组成一个具有层次关系的集合。实现**<u>一对多</u>**。</p>
<p><img src="/2021/01/29/first/%E6%A0%91/image-20210808091141801-1650553611409.png" alt="image-20210808091524985"></p>
<p><strong>特点：</strong></p>
<ol>
<li>每个节点有零个或多个子节点。</li>
<li>没有父节点节点为根节点</li>
<li>每一个非根节点只有一个父节点</li>
<li>每个节点和后代节点整体上看成是一棵树——子树</li>
</ol>
<h2 id="1-2树术语"><a href="#1-2树术语" class="headerlink" title="1.2树术语"></a>1.2树术语</h2><p>结点的度： 一个结点含有的子树的个数称为该结点的度； </p>
<p>叶结点： 度为0的结点称为叶结点，也可以叫做终端结点 </p>
<p>分支结点： 度不为0的结点称为分支结点，也可以叫做非终端结点 </p>
<p>结点的层次： 从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推 </p>
<p>结点的层序编号：将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。 </p>
<p>树的度： 树中所有结点的度的最大值</p>
<p>树的高度(深度)： 树中结点的最大层次 </p>
<p>森林： m（m&gt;&#x3D;0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根 结点，森林就变成一棵树</p>
<p><img src="/2021/01/29/first/%E6%A0%91/image-20210808091524985.png" alt="image-20210808091524985"></p>
<p>孩子结点： 一个结点的直接后继结点称为该结点的孩子结点 </p>
<p>双亲结点(父结点)： 一个结点的直接前驱称为该结点的双亲结点 </p>
<p>兄弟结点： 同一双亲结点的孩子结点间互称兄弟结点</p>
<h2 id="1-3二叉树"><a href="#1-3二叉树" class="headerlink" title="1.3二叉树"></a>1.3二叉树</h2><p>二叉树就是度不超过2的树(每个结点最多有两个子结点)</p>
<p><img src="/2021/01/29/first/%E6%A0%91/image-20210808091705057.png" alt="image-20210808091705057"></p>
<p>**<u>满二叉树</u>**： 一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。</p>
<img src="/2021/01/29/first/%E6%A0%91/image-20210808091845422.png" alt="image-20210808091845422" style="zoom:80%;">

<p><strong><u>完全二叉树：</u></strong> 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p>
<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210808091950505.png" alt="image-20210808091950505" style="zoom:80%;">

<h2 id="1-4二叉树的创建"><a href="#1-4二叉树的创建" class="headerlink" title="1.4二叉树的创建"></a>1.4二叉树的创建</h2><h4 id="1-4-1二叉树节点类"><a href="#1-4-1二叉树节点类" class="headerlink" title="1.4.1二叉树节点类"></a>1.4.1二叉树节点类</h4><h5 id="节点类API"><a href="#节点类API" class="headerlink" title="节点类API"></a>节点类API</h5><table>
<thead>
<tr>
<th>类名</th>
<th>Node&lt;Key,Value&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key key, Value value, Node left, Node right)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public Node left:记录左子结点 <br>2.public Node right:记录右子结点<br>3.public Key key:存储键<br>4.public Value value:存储值</td>
</tr>
</tbody></table>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;Key,Value&gt;&#123;</span><br><span class="line"><span class="comment">//存储键</span></span><br><span class="line"><span class="keyword">public</span> Key key;</span><br><span class="line"><span class="comment">//存储值</span></span><br><span class="line"><span class="keyword">private</span> Value value;</span><br><span class="line"><span class="comment">//记录左子结点</span></span><br><span class="line"><span class="keyword">public</span> Node left;</span><br><span class="line"><span class="comment">//记录右子结点</span></span><br><span class="line"><span class="keyword">public</span> Node right;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.key = key;</span><br><span class="line"><span class="built_in">this</span>.value = value;</span><br><span class="line"><span class="built_in">this</span>.left = left;</span><br><span class="line"><span class="built_in">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2二叉树实现类API"><a href="#1-4-2二叉树实现类API" class="headerlink" title="1.4.2二叉树实现类API"></a>1.4.2二叉树实现类API</h4><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><table>
<thead>
<tr>
<th>类名</th>
<th>BinaryTree,Value value&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>BinaryTree()：创建BinaryTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br> 2.private int N:记录树中元素的个数</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对 <br>2.private Node put(Node x, Key key, Value val)：给指定树x上添加键值对，并返回添加后的新树 <br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值 <br>5.public void delete(Key key):根据key，删除树中对应的键值对 <br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的 新树 <br>7.public int size():获取树中元素的个数</td>
</tr>
</tbody></table>
<h4 id="1-4-3二叉树增删改查思想"><a href="#1-4-3二叉树增删改查思想" class="headerlink" title="1.4.3二叉树增删改查思想"></a>1.4.3二叉树增删改查思想</h4><h5 id="插入方法put思想"><a href="#插入方法put思想" class="headerlink" title="插入方法put思想"></a>插入方法put思想</h5><p><strong><u>本质上，是按照从父到子，从左到右的顺序，寻找一个为空的节点将其放上，并且节点数加一。</u></strong></p>
<p>1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用 <br>        2.如果当前树不为空，则从根结点开始： <br>                         2.1如果新结点的key小于当前结点的key，则继续从左子树上寻找为空的结点； <br>                         2.2如果新结点的key大于当前结点的key，则继续从右子树上寻找为空的结点；<br>                         2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</p>
<h5 id="查询方法get实现思想："><a href="#查询方法get实现思想：" class="headerlink" title="查询方法get实现思想："></a>查询方法get实现思想：</h5><p>从根节点开始： </p>
<p>1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点； </p>
<p>2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点； </p>
<p>3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p>
<h5 id="删除方法delete实现思想："><a href="#删除方法delete实现思想：" class="headerlink" title="删除方法delete实现思想："></a>删除方法delete实现思想：</h5><p>1.找到被删除结点； </p>
<p>2.找到被删除结点右子树中的最小结点minNode </p>
<p>3.删除右子树中的最小结点 </p>
<p>4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子 树 </p>
<p>5.让被删除结点的父节点指向最小结点minNode</p>
<img src="/2021/01/29/first/%E6%A0%91/image-20210808110808650.png" alt="image-20210808110808650" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/image-20210808110822465.png" alt="image-20210808110822465" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210808110822465.png" alt="image-20210808110822465" style="zoom:80%;">

<h4 id="1-4-4代码实现"><a href="#1-4-4代码实现" class="headerlink" title="1.4.4代码实现"></a>1.4.4代码实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tree;</span><br><span class="line"></span><br><span class="line">public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123;</span><br><span class="line">    //记录根节点</span><br><span class="line">    private Node root;</span><br><span class="line">    //记录树中元素的个数</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    public BinaryTree() &#123;</span><br><span class="line">        this.root = null;</span><br><span class="line">        N = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        //存储键</span><br><span class="line">        public Key key;</span><br><span class="line">        //\存储值</span><br><span class="line">        private Value value;</span><br><span class="line">        //记录左子节点</span><br><span class="line">        public Node left;</span><br><span class="line">        // 记录右子节点</span><br><span class="line">        public  Node right;</span><br><span class="line"></span><br><span class="line">        public Node(Key key, Value value, Node left, Node right) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">        public Node() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取节点个数</span><br><span class="line">    public int size()&#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line">    //向树中插入节点</span><br><span class="line">    public  void  put(Key key,Value value)&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    //向指定的树x中添加键值对，并返回添加元素后的新树</span><br><span class="line">    private Node put (Node x, Key key, Value value)&#123;</span><br><span class="line">        //如果树为空</span><br><span class="line">        if (x==null)&#123;</span><br><span class="line">            N++;</span><br><span class="line">            return new Node(key,value,null,null);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果树不为空，直比较节点x的键和key的大小</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if (cmp&gt;0)&#123;</span><br><span class="line">            //key大于x的键值,继续找x节点的右子树</span><br><span class="line">            x.right = put(x.right,key,value);</span><br><span class="line">        &#125;else if (cmp&lt;0)&#123;</span><br><span class="line">            //key小于x的键值,继续找x节点的左子树</span><br><span class="line">            x.left = put(x.left,key,value);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //key等于x的键值，替换x节点的value</span><br><span class="line">            x.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据key值查询对应的value值</span><br><span class="line">    public Value get(Key key)&#123;</span><br><span class="line">        return get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    //向指定的树x中查询某一个key对应的value</span><br><span class="line">    private Value get(Node x,Key key)&#123;</span><br><span class="line">        //如果树为空</span><br><span class="line">        if (x==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果树不为空</span><br><span class="line">        int comp = key.compareTo(x.key);</span><br><span class="line">        if (comp&gt;0)&#123;</span><br><span class="line">            //key大于x的键值,继续找x节点的右子树</span><br><span class="line">            return get(x.right,key);</span><br><span class="line">        &#125;else if (comp&lt;0)&#123;</span><br><span class="line">            //key小于x的键值,继续找x节点的左子树</span><br><span class="line">            return get(x.left,key);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return x.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据key，删除树中对应的键值对</span><br><span class="line">    public void delete(Key key)&#123;</span><br><span class="line">        delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    //向指定树x上，根据key，删除树中对应的键值对</span><br><span class="line">    private Node delete(Node x,Key key)&#123;</span><br><span class="line">        //如果树为空</span><br><span class="line">        if (x==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果树不为空</span><br><span class="line">        int comp = key.compareTo(x.key);</span><br><span class="line">        if (comp&gt;0)&#123;</span><br><span class="line">            //key大于x的键值,继续找x节点的右子树</span><br><span class="line">            x.right = delete(x.right,key);</span><br><span class="line">        &#125;else if (comp&lt;0)&#123;</span><br><span class="line">            //key小于x的键值,继续找x节点的左子树</span><br><span class="line">            x.left = delete(x.left,key);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //完成删除节点动作，要删的就是x</span><br><span class="line">            //从x右子树中找最小的节点，替换当前x节点</span><br><span class="line">            //让元素个数减1</span><br><span class="line">            N--;</span><br><span class="line">            if(x.right==null)&#123;</span><br><span class="line">                return x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (x.left==null)&#123;</span><br><span class="line">                return x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            //找到右子树上最小的节点</span><br><span class="line">            Node minN = x.right;</span><br><span class="line">            while (minN.left!=null)&#123;</span><br><span class="line">                minN = minN.left;</span><br><span class="line">            &#125;</span><br><span class="line">            //删除右子树上最小的节点</span><br><span class="line">            Node n = x.right;</span><br><span class="line">            while (n.left!=null)&#123;</span><br><span class="line">                if (n.left.left!=null)&#123;</span><br><span class="line">                    n=n.left;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    n.left=null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //让x节点的左子树成为minN的左子树</span><br><span class="line">            minN.left = x.left;</span><br><span class="line">            //让x节点的右子树成为minN的右子树</span><br><span class="line">            minN.right = x.right;</span><br><span class="line">            //让x节点的父节点指向minN节点</span><br><span class="line">            x = minN;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-二叉树查找其他便捷方法"><a href="#1-5-二叉树查找其他便捷方法" class="headerlink" title="1.5 二叉树查找其他便捷方法"></a>1.5 二叉树查找其他便捷方法</h2><h3 id="1-5-1-查找二叉树中最小的键"><a href="#1-5-1-查找二叉树中最小的键" class="headerlink" title="1.5.1 查找二叉树中最小的键"></a>1.5.1 查找二叉树中最小的键</h3><table>
<thead>
<tr>
<th>public Key min()</th>
<th>查找整个二叉树中最小的键</th>
</tr>
</thead>
<tbody><tr>
<td>private Node min(Node x)</td>
<td>查找指定树x中最小的键所在的节点</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查找整个二叉树中最小的键</span><br><span class="line">    public Key min()&#123;</span><br><span class="line">        return min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    //查找指定树x中最小的键所在的节点</span><br><span class="line">    private Node min(Node x)&#123;</span><br><span class="line">        Node minNode = x;</span><br><span class="line">        if (x.left==null)&#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        while (minNode.left!=null)&#123;</span><br><span class="line">            if (minNode.left.left!=null)&#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2查找二叉树中最大的键"><a href="#1-5-2查找二叉树中最大的键" class="headerlink" title="1.5.2查找二叉树中最大的键"></a>1.5.2查找二叉树中最大的键</h3><table>
<thead>
<tr>
<th>public Key max()</th>
<th>查找整个二叉树中最大的键</th>
</tr>
</thead>
<tbody><tr>
<td>private Node max(Node x)</td>
<td>查找指定树x中最大的键所在的节点</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用递归的方式完成</span><br><span class="line">//查找整个二叉树中最大的键</span><br><span class="line"> public Key max()&#123;</span><br><span class="line">     if (root==null)&#123;</span><br><span class="line">         return null;</span><br><span class="line">     &#125;</span><br><span class="line">     return max(root).key;</span><br><span class="line"> &#125;</span><br><span class="line"> //查找指定树x中最大的键所在的节点</span><br><span class="line"> private Node max(Node x)&#123;</span><br><span class="line">   if (x.right!=null)&#123;</span><br><span class="line">      return max(x.right);</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">       return x;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-二叉树的基础遍历"><a href="#1-6-二叉树的基础遍历" class="headerlink" title="1.6 二叉树的基础遍历"></a>1.6 二叉树的基础遍历</h2><p>前序遍历：先访问根结点，然后再访问左子树，最后访问右子树</p>
<p>中序遍历：先访问左子树，中间访问根节点，最后访问右子树</p>
<p>后序遍历：先访问左子树，再访问右子树，最后访问根节点</p>
<img src="/2021/01/29/first/%E6%A0%91/image-20210809095659288-1650553981928.png" alt="image-20210809095659288" style="zoom:67%;">



<h3 id="1-6-1-前序遍历"><a href="#1-6-1-前序遍历" class="headerlink" title="1.6.1 前序遍历"></a>1.6.1 前序遍历</h3><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><table>
<thead>
<tr>
<th>public Queue preErgodic()：</th>
<th>使用前序遍历，获取整个树中的所有键</th>
</tr>
</thead>
<tbody><tr>
<td>private void preErgodic(Node x,Queue keys)：</td>
<td>使用前序遍历，把指定树x中的所有键放入到keys队列中</td>
</tr>
</tbody></table>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1.把当前结点的key放入到队列中; <br>        2.找到当前结点的左子树，如果不为空，递归遍历左子树  <br>        3.找到当前结点的右子树，如果不为空，递归遍历右子树</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//前序遍历获取整个树中所有的键</span><br><span class="line">   public Queue&lt;Key&gt; preErgodic()&#123;</span><br><span class="line">       Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">       preErgodic(root,keys);</span><br><span class="line">       return keys;</span><br><span class="line">   &#125;</span><br><span class="line">   //前序遍历，将指定树x中的所有键放在keys中</span><br><span class="line">   private void preErgodic(Node x,Queue&lt;Key&gt; keys)&#123;</span><br><span class="line">       if (x==null)&#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       //把当前节点的key放在队列中</span><br><span class="line">       keys.enEqueu(x.key);</span><br><span class="line">       //找到当前节点的左子树，如果不为空，递归遍历左子树</span><br><span class="line">       if (x.left!=null)&#123;</span><br><span class="line">           preErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       //找到当前节点的右子树，如果不为空，递归遍历左子树</span><br><span class="line">       if (x.right!=null)&#123;</span><br><span class="line">           preErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-2-中序遍历"><a href="#1-6-2-中序遍历" class="headerlink" title="1.6.2 中序遍历"></a>1.6.2 中序遍历</h3><h4 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h4><table>
<thead>
<tr>
<th>public Queue minErgodic()：</th>
<th>使用中序遍历，获取整个树中的所有键</th>
</tr>
</thead>
<tbody><tr>
<td>private void minErgodic(Node x,Queue keys)：</td>
<td>使用中序遍历，把指定树x中的所有键放入到keys队列中</td>
</tr>
</tbody></table>
<h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1.找到当前结点的左子树，如果不为空，递归遍历左子树  </p>
<p>2.把当前结点的key放入到队列中; <br>        3.找到当前结点的右子树，如果不为空，递归遍历右子树</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/中序遍历获取整个树中所有的键</span><br><span class="line">    public Queue&lt;Key&gt; minErgodic()&#123;</span><br><span class="line">        Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">        minErgodic(root,keys);</span><br><span class="line">        return keys;</span><br><span class="line">    &#125;</span><br><span class="line">    //中序遍历，将指定树x中的所有键放在keys中</span><br><span class="line">     private void minErgodic(Node x,Queue&lt;Key&gt; keys)&#123;</span><br><span class="line">        if (x==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到当前节点的左子树，如果不为空，递归遍历左子树</span><br><span class="line">        if (x.left!=null)&#123;</span><br><span class="line">            minErgodic(x.left,keys);</span><br><span class="line">        &#125;</span><br><span class="line">        //把当前节点的key放在队列中</span><br><span class="line">        keys.enEqueu(x.key);</span><br><span class="line">        //找到当前节点的右子树，如果不为空，递归遍历左子树</span><br><span class="line">        if (x.right!=null)&#123;</span><br><span class="line">            minErgodic(x.right,keys);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-6-3-后序遍历"><a href="#1-6-3-后序遍历" class="headerlink" title="1.6.3 后序遍历"></a>1.6.3 后序遍历</h3><h4 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h4><table>
<thead>
<tr>
<th>public Queue afterErgodic()：</th>
<th>使用后序遍历，获取整个树中的所有键</th>
</tr>
</thead>
<tbody><tr>
<td>private void afterErgodic(Node x,Queue keys)：</td>
<td>使用后序遍历，把指定树x中的所有键放入到keys队列中</td>
</tr>
</tbody></table>
<h4 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1.找到当前结点的左子树，如果不为空，递归遍历左子树  </p>
<p>2.找到当前结点的右子树，如果不为空，递归遍历右子树</p>
<p>3.把当前结点的key放入到队列中; <br></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//后序遍历获取整个树中所有的键</span><br><span class="line">  public Queue&lt;Key&gt; afterErgodic()&#123;</span><br><span class="line">      Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">      afterErgodic(root,keys);</span><br><span class="line">      return keys;</span><br><span class="line">  &#125;</span><br><span class="line">  //后序遍历，将指定树x中的所有键放在keys中</span><br><span class="line">   private void afterErgodic(Node x,Queue&lt;Key&gt; keys)&#123;</span><br><span class="line">      if (x==null)&#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      //找到当前节点的左子树，如果不为空，递归遍历左子树</span><br><span class="line">      if (x.left!=null)&#123;</span><br><span class="line">          afterErgodic(x.left,keys);</span><br><span class="line">      &#125;</span><br><span class="line">      //找到当前节点的右子树，如果不为空，递归遍历左子树</span><br><span class="line">      if (x.right!=null)&#123;</span><br><span class="line">          afterErgodic(x.right,keys);</span><br><span class="line">      &#125;</span><br><span class="line">      //把当前节点的key放在队列中</span><br><span class="line">      keys.enEqueu(x.key);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-二叉树的层序遍历"><a href="#1-7-二叉树的层序遍历" class="headerlink" title="1.7 二叉树的层序遍历"></a>1.7 二叉树的层序遍历</h2><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210809142736482.png" alt="image-20210809142736482" style="zoom:80%;">

<p>一层一层的遍历，如图结果为：EBGADFHC</p>
<h3 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h3><table>
<thead>
<tr>
<th>成员方法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public Queue layerErgodic()：</td>
<td>使用层序遍历，获取整个树中的所有键</td>
</tr>
</tbody></table>
<h3 id="实现步骤-3"><a href="#实现步骤-3" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>1.创建队列，存储每一层的结点； <br>        2.使用循环从队列中弹出一个结点： <br>                 2.1获取当前结点的key；  <br>                 2.2如果当前结点的左子结点不为空，则把左子结点放入到队列中  <br>                 2.3如果当前结点的右子结点不为空，则把右子结点放入到队列中</p>
<img src="/2021/01/29/first/%E6%A0%91/image-20210809154339828.png" alt="image-20210809154339828" style="zoom:80%;">

<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用层序遍历得到所有节点的key值</span><br><span class="line">   public Queue&lt;Key&gt; layerErgodic()&#123;</span><br><span class="line">      if (root==null)&#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      //定义两个队列，分别存储树中的键和树中的节点</span><br><span class="line">       Queue&lt;Key&gt; keys = new Queue&lt;&gt;();</span><br><span class="line">       Queue&lt;Node&gt; nodes = new Queue&lt;&gt;();</span><br><span class="line">       //默认向队列中放入根节点</span><br><span class="line">       nodes.enEqueu(root);</span><br><span class="line">       while (!nodes.isEmpty())&#123;</span><br><span class="line">           //从队列中弹出一个根节点，并将其key放在keys队列中</span><br><span class="line">           Node putNode = nodes.deQueue();</span><br><span class="line">           keys.enEqueu(putNode.key);</span><br><span class="line">           //判断当前节点还有没有左子节点，如果有就放入队列</span><br><span class="line">           if (putNode.left!=null)&#123;</span><br><span class="line">               nodes.enEqueu(putNode.left);</span><br><span class="line">           &#125;</span><br><span class="line">           //判断当前节点还有没有右子节点，如果有就放入队列</span><br><span class="line">           if (putNode.right!=null)&#123;</span><br><span class="line">               nodes.enEqueu(putNode.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return keys;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-8-二叉树的最大深度问题"><a href="#1-8-二叉树的最大深度问题" class="headerlink" title="1.8 二叉树的最大深度问题"></a>1.8 二叉树的最大深度问题</h2><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210809154607860.png" alt="image-20210809154607860" style="zoom: 67%;">

<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>树的根节点到最远叶子结点的最长路径上的结点数：4</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>1.如果根结点为空，则最大深度为0； <br>        2.计算左子树的最大深度； <br>        3.计算右子树的最大深度； <br>        4.当前树的最大深度&#x3D;左子树的最大深度和右子树的最大深度中的较大者+1</p>
<h3 id="API-5"><a href="#API-5" class="headerlink" title="API"></a>API</h3><table>
<thead>
<tr>
<th>public int maxDepth()</th>
<th>计算整个树的最大深度</th>
</tr>
</thead>
<tbody><tr>
<td>private int maxDepth(Node x):</td>
<td>计算指定树x的最大深度</td>
</tr>
</tbody></table>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//计算整个树的最大深度</span><br><span class="line">public int maxDepth()&#123;</span><br><span class="line">    if (root==null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return maxDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//计算指定树的最大深度</span><br><span class="line">private int maxDepth(Node x)&#123;</span><br><span class="line">    //初始化树x的左右子树最大深度为0</span><br><span class="line">    int rightMax = 0;</span><br><span class="line">    int leftMax = 0;</span><br><span class="line">    //计算左子树的最大深度</span><br><span class="line">    if (x.left!=null)&#123;</span><br><span class="line">        leftMax = maxDepth(x.left);</span><br><span class="line">    &#125;</span><br><span class="line">    //计算左子树的最大深度</span><br><span class="line">    if (x.right!=null)&#123;</span><br><span class="line">        rightMax =maxDepth(x.right);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回左右子树最大深度的最大值+1</span><br><span class="line">    return (rightMax&gt;leftMax?rightMax:leftMax)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-9-折纸问题"><a href="#1-9-折纸问题" class="headerlink" title="1.9 折纸问题"></a>1.9 折纸问题</h2><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折 痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上 到下依次是下折痕、下折痕和上折痕。 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 例如：N&#x3D;1时，打 印： down；N&#x3D;2时，打印： down down up</p>
<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210809175207088.png" alt="image-20210809175207088" style="zoom:80%;">

<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折 痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构 来描述对折后产生的折痕。</p>
<p>树的特点：</p>
<p>​      1.根结点为下折痕； <br>              2.每一个结点的左子结点为下折痕； <br>              3.每一个结点的右子结点为上折痕；</p>
<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210809175414437.png" alt="image-20210809175414437" style="zoom:80%;">

<h3 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h3><p> 1.定义结点类<br>         2.构建**<u>深度为N的折痕树</u><strong>； <br>         3.使用</strong><u>中序遍历</u>**，打印出树中所有结点的内容；</p>
<p>自己的思路：生成一棵深度为N 的满二叉树，节点的key值为1~2^n-1；采用**<u>层叙遍历</u><strong>的方式，将down和up存入对应的value值中；最后采用</strong><u>中序遍历</u>**的形式打印输出。</p>
<h3 id="构建深度为N的折痕树："><a href="#构建深度为N的折痕树：" class="headerlink" title="构建深度为N的折痕树："></a>构建深度为N的折痕树：</h3><p>1.第一次对折，只有一条折痕，创建根结点； <br>        2.如果不是第一次对折，则使用队列保存根结点； <br>        3.循环遍历队列： <br>                    3.1从队列中拿出一个结点； <br>                    3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中； <br>                   3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中； <br>                   3.4判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一 个值为up的右子结点。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tree.test;</span><br><span class="line"></span><br><span class="line">import linear.linkedList.Queue;</span><br><span class="line"></span><br><span class="line">public class PageFoldingTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node tree = createTree(5);</span><br><span class="line">        printTree(tree);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //定义节点类</span><br><span class="line">    private static class Node&lt;T&gt;&#123;</span><br><span class="line">        private T item;</span><br><span class="line">        private Node left;</span><br><span class="line">        private Node right;</span><br><span class="line"></span><br><span class="line">        public Node(T item, Node left, Node right) &#123;</span><br><span class="line">            this.item = item;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static Node createTree(int N) &#123;</span><br><span class="line">        Node root = null;</span><br><span class="line">        for (int i = 0; i &lt;N ; i++) &#123;</span><br><span class="line">            if (i==0)&#123;</span><br><span class="line">                //1.第一次对折，只有一条折痕，创建根结点；</span><br><span class="line">                root = new Node(&quot;down&quot;,null,null);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //2.如果不是第一次对折，则使用队列保存根结点；</span><br><span class="line">                Queue&lt;Node&gt; queue = new Queue&lt;&gt;();</span><br><span class="line">                queue.enEqueu(root);</span><br><span class="line">                //3.循环遍历队列：让一颗树按层生长的方法</span><br><span class="line">                while(!queue.isEmpty())&#123;</span><br><span class="line">                    //3.1从队列中拿出一个结点；</span><br><span class="line">                    Node tmp = queue.deQueue();</span><br><span class="line">                    //3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；</span><br><span class="line">                    if (tmp.left!=null)&#123;</span><br><span class="line">                        queue.enEqueu(tmp.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；</span><br><span class="line">                    if (tmp.right!=null)&#123;</span><br><span class="line">                        queue.enEqueu(tmp.right);</span><br><span class="line">                    &#125;</span><br><span class="line">      //3.4判断当前结点的左子结点和右子结点都为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。</span><br><span class="line">                    if (tmp.left==null &amp;&amp; tmp.right==null)&#123;</span><br><span class="line">                        tmp.left = new Node(&quot;down&quot;,null,null);</span><br><span class="line">                        tmp.right = new Node(&quot;up&quot;,null,null);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历，打印每个节点的内容</span><br><span class="line">    private static  void  printTree(Node tree)&#123;</span><br><span class="line">        if (tree==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到当前节点的左子树，如果不为空，递归遍历左子树</span><br><span class="line">        if (tree.left!=null)&#123;</span><br><span class="line">            printTree(tree.left);</span><br><span class="line">        &#125;</span><br><span class="line">        //打印输出当前节点的item</span><br><span class="line">        System.out.print(tree.item+&quot;,&quot;);</span><br><span class="line">        //找到当前节点的右子树，如果不为空，递归遍历左子树</span><br><span class="line">        if (tree.right!=null)&#123;</span><br><span class="line">           printTree(tree.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自己的构造深度为N-的折痕树的方法"><a href="#自己的构造深度为N-的折痕树的方法" class="headerlink" title="自己的构造深度为N 的折痕树的方法"></a>自己的构造深度为N 的折痕树的方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//构造深度为n的折痕树,按层进行插入</span><br><span class="line">   private static Node createTree(int n)&#123;</span><br><span class="line">       Node root =null;</span><br><span class="line">       Queue nodes = new Queue();</span><br><span class="line">       for (int i=0;i&lt;n;i++)&#123;</span><br><span class="line">          //第一次折叠</span><br><span class="line">           if (i==0)&#123;</span><br><span class="line">               root = new Node(&quot;down&quot;,null,null);</span><br><span class="line">               nodes.enEqueu(root);</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           //记录上一层的节点个数</span><br><span class="line">           int size = nodes.size();</span><br><span class="line">           //不是第一次折叠</span><br><span class="line">           while (size!=0)&#123;</span><br><span class="line">               Node getN = (Node) nodes.deQueue();</span><br><span class="line">               getN.left = new Node(&quot;down&quot;,null,null);</span><br><span class="line">               getN.right = new Node(&quot;up&quot;,null,null);</span><br><span class="line">               nodes.enEqueu(getN.left);</span><br><span class="line">               nodes.enEqueu(getN.right);</span><br><span class="line">               size--;</span><br><span class="line">               //这里结束后，队列中记录的是本次插入的所有节点个数</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、堆Heap"><a href="#二、堆Heap" class="headerlink" title="二、堆Heap"></a>二、堆Heap</h1><h3 id="lt-1-gt-堆的实现"><a href="#lt-1-gt-堆的实现" class="headerlink" title="&lt;1&gt;堆的实现"></a>&lt;1&gt;堆的实现</h3><h4 id="2-1堆的定义"><a href="#2-1堆的定义" class="headerlink" title="2.1堆的定义"></a>2.1堆的定义</h4><p>看成是完全二叉树的**<u>数组对象</u>**</p>
<h4 id="2-2特性"><a href="#2-2特性" class="headerlink" title="2.2特性"></a>2.2特性</h4><p>1.它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不 是满的，那么要求左满右不满。</p>
<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810152156534.png" alt="image-20210810152156534" style="zoom:80%;">

<p>2.通常用数组实现，将二叉树的结点按照层级顺序放入数组中。</p>
<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810152431995.png" alt="image-20210810152431995" style="zoom:80%;">

<p><strong><u>一个结点的位置为k，则它的父结点的位置为[k&#x2F;2],而它的两个子结点的位置则分别为2k和2k+1。</u></strong></p>
<p><strong><u>可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k&#x2F;2,向下一层就 令k等于2k或2k+1。</u></strong></p>
<p><strong><u>数组的第一个位置一般不放元素，使得数组索引即为堆元素的序数</u></strong></p>
<p>3.每个结点都**<u>大于等于</u>**它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这<u><strong>两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</strong></u></p>
<h4 id="2-3-API"><a href="#2-3-API" class="headerlink" title="2.3 API"></a>2.3 API</h4><table>
<thead>
<tr>
<th>类名</th>
<th>Heap&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Heap(int capacity)：创建容量为capacity的Heap对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 <br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值 <br>3.public T delMax():删除堆中最大的元素,并返回这个最大元素 <br>4.public void insert(T t)：往堆中插入一个元素 <br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 <br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组 <br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<h4 id="2-4-实现思想"><a href="#2-4-实现思想" class="headerlink" title="2.4 实现思想"></a>2.4 实现思想</h4><h5 id="2-4-1-元素插入"><a href="#2-4-1-元素插入" class="headerlink" title="2.4.1 元素插入"></a>2.4.1 元素插入</h5><p>在数组尾部（索引为++N）的位置插入元素，也就是在堆的最右下方插入元素。此时，很有可能不满足堆的第三大特性。采用上浮算法实现重新排序，即：</p>
<p><strong><u>要不断的比较新结点a[k]和它的父结点a[k&#x2F;2]的大小，然后根据结果完成 数据元素的交换</u></strong></p>
<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810153319389.png" alt="image-20210810153319389" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810153421384.png" alt="image-20210810153421384" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810153435415.png" alt="image-20210810153435415" style="zoom:80%;">

<p>![image-20210810153453801](C:\Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810153453801.png)</p>
<h5 id="2-4-2最大元素删除"><a href="#2-4-2最大元素删除" class="headerlink" title="2.4.2最大元素删除"></a>2.4.2最大元素删除</h5><p>索引1处的元素，即为最大的元素，当我们把根结点的元素删除后，需有一个新的根结点出现。暂时把堆中最后一个元素放到索引1处，充当根结点。采用下沉算法实现重新排序。</p>
<p><strong><u>当删除掉最大元素后，只需要将最后一个元素放到索引1处，并不断的拿着当前结点a[k]与它的子结点a[2k] 和a[2k+1]中的较大者交换位置，即可完成堆的有序调整。</u></strong></p>
<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810154130883.png" alt="image-20210810154130883" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810154142614.png" alt="image-20210810154142614" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810154205193.png" alt="image-20210810154205193" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810154218953.png" alt="image-20210810154218953" style="zoom:80%;">

<p>![image-20210810154230452](C:\Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810154230452.png)</p>
<h4 id="2-5-代码"><a href="#2-5-代码" class="headerlink" title="2.5 代码"></a>2.5 代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tree;</span><br><span class="line"></span><br><span class="line">public class Heap&lt;T extends Comparable&gt; &#123;</span><br><span class="line">    //创建一个数组，存储堆中的元素</span><br><span class="line">    private T[] items;</span><br><span class="line">    //记录堆中元素的个数</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    public Heap(int capacity) &#123;</span><br><span class="line">        this.items = (T[]) new Comparable[capacity+1];</span><br><span class="line">        N = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断堆中索引i处的元素是否小于索引j处的元素</span><br><span class="line">    private boolean less(int i,int j)&#123;</span><br><span class="line">        return items[i].compareTo(items[j])&lt;0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //交换堆中i索引和j索引处的值</span><br><span class="line">    private void exch(int i,int j)&#123;</span><br><span class="line">        T tmp = items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //往堆中插入一个元素</span><br><span class="line">    public void insert(T t)&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line">    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span><br><span class="line">    private void swim(int k)&#123;</span><br><span class="line">        while (k&gt;1)&#123;</span><br><span class="line">            //比较父节点和当前节点的大小</span><br><span class="line">            if (less(k/2,k))&#123;</span><br><span class="line">                exch(k/2,k);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //父节点和当前节点相等或者比当前节点大的时候终止循环</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            k=k/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除堆中最大的元素,并返回这个最大元素</span><br><span class="line">    public T delMax()&#123;</span><br><span class="line">        T max = items[1];</span><br><span class="line">        //交换索引1和N的值</span><br><span class="line">        exch(1,N);</span><br><span class="line">        //删除最后位置上的元素，并让元素个数减1</span><br><span class="line">        items[N--]=null;</span><br><span class="line">        sink(1);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span><br><span class="line">    private void sink(int k)&#123;</span><br><span class="line">        //保证当前节点有下一层</span><br><span class="line">        while (2*k&lt;=N)&#123;</span><br><span class="line">            //找到当前节点子节点中的最大值</span><br><span class="line">            int maxIndex = 0;</span><br><span class="line">            if (2*k+1&gt;N)&#123;//不存在右子节点</span><br><span class="line">                maxIndex = 2*k;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                if (less(2*k,2*k+1))&#123;</span><br><span class="line">                    maxIndex = 2*k+1;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    maxIndex = 2*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果当前节点较小,则交换，否则终止循环</span><br><span class="line">            if (less(k,maxIndex))&#123;</span><br><span class="line">                exch(k,maxIndex);</span><br><span class="line">                k=maxIndex;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lt-1-gt-堆的排序"><a href="#lt-1-gt-堆的排序" class="headerlink" title="&lt;1&gt;堆的排序"></a>&lt;1&gt;堆的排序</h3><h4 id="2-6-需求"><a href="#2-6-需求" class="headerlink" title="2.6 需求"></a>2.6 需求</h4><p>给定一个数组： String[] arr &#x3D; {“S”,”O”,”R”,”T”,”E”,”X”,”A”,”M”,”P”,”L”,”E”}；实现数组中字符串的**<u>从小到大排序</u>**</p>
<h4 id="2-7-实现步骤"><a href="#2-7-实现步骤" class="headerlink" title="2.7 实现步骤"></a>2.7 实现步骤</h4><p>1.构造堆；</p>
<p>2.堆排序</p>
<p>​             2.1 交换堆顶元素和最后一个元素</p>
<p>​             2.2 采用下沉算法，让除了最后一个元素的剩余元素参与下沉，让这些元素中的最大值放到堆顶。</p>
<p>​             2.3 重复1-2步，直到参与下沉的元素剩下一个为止。此时，堆中元素从顶到下有序（从小到大）。</p>
<p>3.将堆对应的数组复制到需求排序的数组。</p>
<h5 id="2-7-1-构造堆"><a href="#2-7-1-构造堆" class="headerlink" title="2.7.1 构造堆"></a>2.7.1 构造堆</h5><p><strong>思路一：</strong>创建一个新的heap数组，遍历原数组，每得到一个元素后，添加到新的数组中，**<u>通过上浮</u>**，对堆进行调整，最后新的数组就是一个堆。</p>
<p><strong>思路二</strong>（更高级）：创建一个新的数组，直接copy原数组。**<u>把原数组 0<del>length-1的数据拷贝到新数组的1</del>length处</u>**，从新数组的<u><strong>最大索引（元素个数）&#x2F;2</strong></u>的位置开始向索引为1的位置扫描（从右向左），对扫描到的每一个元素做下沉调整。</p>
<p>为什么要在最大索引的一半处开始？**<u>因为一半之后恰好都是叶子结点，不需要进行下沉操作。</u>**</p>
<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185303522.png" alt="image-20210810185303522" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185316368.png" alt="image-20210810185316368" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185327144.png" alt="image-20210810185327144" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185400169.png" alt="image-20210810185400169" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185414115.png" alt="image-20210810185414115" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185414115.png" alt="image-20210810185414115" style="zoom:80%;">

<h5 id="2-7-2-堆排序"><a href="#2-7-2-堆排序" class="headerlink" title="2.7.2 堆排序"></a>2.7.2 堆排序</h5><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185628525.png" alt="image-20210810185628525" style="zoom:80%;">

<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185738589.png" alt="image-20210810185738589" style="zoom:80%;">

<p><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185753247.png" alt="image-20210810185753247" style="zoom:80%;">![image-20210810185807659](C:\Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185807659.png)</p>
<p><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185753247.png" alt="image-20210810185753247" style="zoom:80%;"><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185807659.png" alt="image-20210810185807659" style="zoom:80%;"></p>
<p><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185826253.png" alt="image-20210810185826253" style="zoom:80%;"><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185904639.png" alt="image-20210810185904639" style="zoom:80%;"><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810185926995.png" alt="image-20210810185926995" style="zoom:80%;">![image-20210810190044370](C:\Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810190044370.png)</p>
<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810190044370.png" alt="image-20210810190044370" style="zoom:80%;">

<p><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810190141532.png" alt="image-20210810190141532" style="zoom:80%;"><img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810190156616.png" alt="image-20210810190156616" style="zoom:80%;"></p>
<img src="/2021/01/29/first/%E6%A0%91/Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210810190238005.png" alt="image-20210810190238005" style="zoom:80%;">

<h4 id="2-8-API"><a href="#2-8-API" class="headerlink" title="2.8 API"></a>2.8 API</h4><table>
<thead>
<tr>
<th>类名</th>
<th>HeapSort&lt;&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] source)：对source数组中的数据从小到大排序 <br><br>2.private static void createHeap(Comparable[] source, Comparable[] heap):根据原数组 source，构造出堆heap <br><br>3.private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否 小于索引j处的元素 <br><br>4.private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值 <br><br>5.private static void sink(Comparable[] heap, int target, int range):在heap堆中，对target处的 元素做下沉，范围是targe~range。<br></td>
</tr>
</tbody></table>
<h4 id="2-9-代码实现"><a href="#2-9-代码实现" class="headerlink" title="2.9 代码实现"></a>2.9 代码实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package HeapSort;</span><br><span class="line"></span><br><span class="line">public class HeapSort &#123;</span><br><span class="line">    //对source数组中的数据从小到大排序</span><br><span class="line">    public static void sort(Comparable[] source)&#123;</span><br><span class="line">        Comparable[] heap =new Comparable[source.length+1];</span><br><span class="line">        //1.构造堆</span><br><span class="line">        createHeap(source,heap);</span><br><span class="line">        //2.堆排序</span><br><span class="line">        int last = heap.length-1;</span><br><span class="line">        while (last&gt;1)&#123;</span><br><span class="line">            //2.1 交换索引1和last处的元素</span><br><span class="line">            exch(heap,1,last);</span><br><span class="line">            //2.2 对索引1处的元素在1到last范围做下沉操作</span><br><span class="line">            last--;</span><br><span class="line">            sink(heap,1,last);</span><br><span class="line">        &#125;</span><br><span class="line">        //3.heap数组中的元素拷贝到source</span><br><span class="line">        System.arraycopy(heap,1,source,0,source.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //根据原数组 source，构造出堆heap</span><br><span class="line">    private static void createHeap(Comparable[] source,Comparable[] heap)&#123;</span><br><span class="line">        //1.拷贝原数组</span><br><span class="line">        System.arraycopy(source,0,heap,1,source.length);</span><br><span class="line">        //2.从最大索引的一半处开始向索引为1的位置遍历，对每个元素进行下沉操作</span><br><span class="line">        for (int i=( heap.length-1)/2;i&gt;0;i--)&#123;</span><br><span class="line">            sink(heap,i,heap.length-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断heap堆中索引i处的元素是否小于索引j处的元素</span><br><span class="line">    private static boolean less(Comparable[] heap,int i, int j)&#123;</span><br><span class="line">        return heap[i].compareTo(heap[j])&lt;0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //交换heap堆中i索引和j索引处的值</span><br><span class="line">    private static void exch(Comparable[] heap, int i, int j)&#123;</span><br><span class="line">        Comparable temp = heap[i];</span><br><span class="line">        heap[i]=heap[j];</span><br><span class="line">        heap[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //在heap堆中，对target处的元素做下沉，范围是targe~range</span><br><span class="line">    private static void sink(Comparable[] heap, int target, int range)&#123;</span><br><span class="line">        while (2*target&lt;=range)&#123;</span><br><span class="line">            int max = 2*target;</span><br><span class="line">            if (2*target+1&lt;=range &amp;&amp; less(heap,2*target,2*target+1))&#123;</span><br><span class="line">                max =2*target+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果当前节点的值小于子节点中的较大值，则交换</span><br><span class="line">            if (less(heap,target,max))&#123;</span><br><span class="line">                exch(heap,max,target);</span><br><span class="line">            &#125;</span><br><span class="line">            target = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line"> public static void main(String[] args) throws Exception &#123;</span><br><span class="line">            String[] arr = &#123;&quot;S&quot;, &quot;O&quot;, &quot;R&quot;, &quot;T&quot;, &quot;E&quot;, &quot;X&quot;, &quot;A&quot;, &quot;M&quot;, &quot;P&quot;, &quot;L&quot;, &quot;E&quot;&#125;;</span><br><span class="line">            HeapSort.sort(arr);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、优先队列（大顶堆，小顶堆）"><a href="#三、优先队列（大顶堆，小顶堆）" class="headerlink" title="三、优先队列（大顶堆，小顶堆）"></a>三、优先队列（大顶堆，小顶堆）</h1><p>在队列中，每次可弹出**<u>最大或最小</u>**元素的队列称为优先队列。现实生活中有很多类似的场景，比如计算机任务的执行，会根据任务的优先级分配cpu。</p>
<p>最大优先队列： 可以获取并删除队列中最大的值 </p>
<p>最小优先队列： 可以获取并删除队列中最小的值</p>
<h2 id="3-1最大优先队列（大定堆）"><a href="#3-1最大优先队列（大定堆）" class="headerlink" title="3.1最大优先队列（大定堆）"></a>3.1最大优先队列（大定堆）</h2><p>与堆的构造**<u>完全一样</u>**，因为堆就可以实现最大元素的删除。</p>
<h3 id="3-1-1API"><a href="#3-1-1API" class="headerlink" title="3.1.1API"></a>3.1.1API</h3><table>
<thead>
<tr>
<th>类名</th>
<th>Heap&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Heap(int capacity)：创建容量为capacity的Heap对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 <br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值 <br>3.public T delMax():删除堆中最大的元素,并返回这个最大元素 <br>4.public void insert(T t)：往堆中插入一个元素 <br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 <br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br>7.public int size():获取队列中元素的个数<br>8.public boolean isEmpty():判断队列是否为空</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组 <br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<h3 id="3-1-2代码实现"><a href="#3-1-2代码实现" class="headerlink" title="3.1.2代码实现"></a>3.1.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tree;</span><br><span class="line"></span><br><span class="line">public class MaxPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line">    //创建一个数组，存储堆中的元素</span><br><span class="line">    private T[] items;</span><br><span class="line">    //记录堆中元素的个数</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    public MaxPriorityQueue(int capacity) &#123;</span><br><span class="line">        this.items = (T[]) new Comparable[capacity+1];</span><br><span class="line">        N = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取队列中元素的个数</span><br><span class="line">    public int size()&#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断队列是否为空</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return N==0;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断堆中索引i处的元素是否小于索引j处的元素</span><br><span class="line">    private boolean less(int i,int j)&#123;</span><br><span class="line">        return items[i].compareTo(items[j])&lt;0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //交换堆中i索引和j索引处的值</span><br><span class="line">    private void exch(int i,int j)&#123;</span><br><span class="line">        T tmp = items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //往堆中插入一个元素</span><br><span class="line">    public void insert(T t)&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line">    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span><br><span class="line">    private void swim(int k)&#123;</span><br><span class="line">        while (k&gt;1)&#123;</span><br><span class="line">            //比较父节点和当前节点的大小</span><br><span class="line">            if (less(k/2,k))&#123;</span><br><span class="line">                exch(k/2,k);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //父节点和当前节点相等或者比当前节点大的时候终止循环</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            k=k/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除堆中最大的元素,并返回这个最大元素</span><br><span class="line">    public T delMax()&#123;</span><br><span class="line">        T max = items[1];</span><br><span class="line">        //交换索引1和N的值</span><br><span class="line">        exch(1,N);</span><br><span class="line">        //删除最后位置上的元素，并让元素个数减1</span><br><span class="line">        items[N--]=null;</span><br><span class="line">        sink(1);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span><br><span class="line">    private void sink(int k)&#123;</span><br><span class="line">        //保证当前节点有下一层</span><br><span class="line">        while (2*k&lt;=N)&#123;</span><br><span class="line">            //找到当前节点子节点中的最大值</span><br><span class="line">            int maxIndex = 2*k;</span><br><span class="line">            if (2*k+1&lt;=N &amp;&amp; less(2*k,2*k+1))&#123;//存在右子节点且右节点较大</span><br><span class="line">                maxIndex = 2*k+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果当前节点较小,则交换，否则终止循环</span><br><span class="line">            if (less(k,maxIndex))&#123;</span><br><span class="line">                exch(k,maxIndex);</span><br><span class="line">                k=maxIndex;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">public class MaxPriorityQueueTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建优先队列并存数据</span><br><span class="line">        String[] arr = &#123;&quot;S&quot;, &quot;O&quot;, &quot;R&quot;, &quot;T&quot;, &quot;E&quot;, &quot;X&quot;, &quot;A&quot;, &quot;M&quot;, &quot;P&quot;, &quot;L&quot;, &quot;E&quot;&#125;;</span><br><span class="line">        MaxPriorityQueue&lt;String&gt; maxpq = new MaxPriorityQueue&lt;&gt;(20);</span><br><span class="line">        for (String s : arr) &#123;</span><br><span class="line">            maxpq.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        //通过循环获取最大元素</span><br><span class="line">        while (!maxpq.isEmpty())&#123;</span><br><span class="line">            System.out.print(maxpq.delMax()+&quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2最小优先队列（小顶堆）"><a href="#3-2最小优先队列（小顶堆）" class="headerlink" title="3.2最小优先队列（小顶堆）"></a>3.2最小优先队列（小顶堆）</h2><h4 id="3-2-1-特性：（与堆的实现相反）"><a href="#3-2-1-特性：（与堆的实现相反）" class="headerlink" title="3.2.1 特性：（与堆的实现相反）"></a>3.2.1 特性：（与堆的实现相反）</h4><p>1.最小的元素放在数组索引为1的位置。</p>
<p>2.每个节点的数据总是小于等于它的两个子节点的数据。</p>
<h4 id="3-2-2-API"><a href="#3-2-2-API" class="headerlink" title="3.2.2 API"></a>3.2.2 API</h4><table>
<thead>
<tr>
<th>类名</th>
<th>MinPriorityQueue<T></T></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 <br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值 <br>3.public T delMin():删除队列中最小的元素,并返回这个最小元素 <br>4.public void insert(T t)：往队列中插入一个元素<br> 5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 <br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 <br>7.public int size():获取队列中元素的个数 <br>8.public boolean isEmpty():判断队列是否为空</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组 <br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<h4 id="3-2-3-代码"><a href="#3-2-3-代码" class="headerlink" title="3.2.3 代码"></a>3.2.3 代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tree;</span><br><span class="line"></span><br><span class="line">public class MinPriorityQueue &lt;T extends Comparable&lt;T&gt;&gt;&#123;</span><br><span class="line">    private T[] items;</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    public MinPriorityQueue(int capacity) &#123;</span><br><span class="line">        this.items = (T[])new Comparable[capacity+1];</span><br><span class="line">        N = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size()&#123;</span><br><span class="line">        return  N;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return N==0;</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(T t)&#123;</span><br><span class="line">        items[++N]=t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line">    public T delMin()&#123;</span><br><span class="line">        T min = items[1];</span><br><span class="line">        exch(1,N);</span><br><span class="line">        items[N--]=null;</span><br><span class="line">        sink(1);</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean less(int i, int j)&#123;</span><br><span class="line">        return items[i].compareTo(items[j])&lt;0;</span><br><span class="line">    &#125;</span><br><span class="line">    private void exch (int i,int j)&#123;</span><br><span class="line">        T temp;</span><br><span class="line">        temp = items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sink(int k)&#123;</span><br><span class="line">        while (2*k&lt;=N)&#123;</span><br><span class="line">            //找到当前节点子节点中最小的节点索引</span><br><span class="line">            int minIndex = 2*k;</span><br><span class="line">            if (2*k+1&lt;=N &amp;&amp; less(2*k+1,2*k))&#123;</span><br><span class="line">                minIndex = 2*k+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断当前节点是否比子节点最小节点大</span><br><span class="line">            if (less(minIndex,k))&#123;</span><br><span class="line">                exch(minIndex,k);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //下沉一层</span><br><span class="line">            k = minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void swim(int k)&#123;</span><br><span class="line">        while (k&gt;1)&#123;</span><br><span class="line">            if (less(k,k/2))&#123;</span><br><span class="line">                exch(k,k/2);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">public class MinPriorityQueueTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建优先队列并存数据</span><br><span class="line">        String[] arr = &#123;&quot;S&quot;, &quot;O&quot;, &quot;R&quot;, &quot;T&quot;, &quot;E&quot;, &quot;X&quot;, &quot;A&quot;, &quot;M&quot;, &quot;P&quot;, &quot;L&quot;, &quot;E&quot;&#125;;</span><br><span class="line">        MinPriorityQueue&lt;String&gt; maxpq = new MinPriorityQueue(20);</span><br><span class="line">        for (String s : arr) &#123;</span><br><span class="line">            maxpq.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        //通过循环获取最小元素</span><br><span class="line">        while (!maxpq.isEmpty())&#123;</span><br><span class="line">            System.out.print(maxpq.delMin()+&quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3索引优先队列"><a href="#3-3索引优先队列" class="headerlink" title="3.3索引优先队列"></a>3.3索引优先队列</h2><p>索引优先队列同样分为**<u>最小索引优先队列</u><strong>和</strong><u>最大索引优先队列</u>**。</p>
<p>其实质是，有3个数组：</p>
<p>​                  1个原数组items  ——用来存放元素</p>
<p>​                  1个堆数组pq      ——存放原数组元素经堆排序后元素在原数组的索引（也就是说堆中存的不是元素，存的是元素的索引）</p>
<p>​                  1个附加组数qp ——存放原数组元素经堆排序在堆数组中的位置（索引）{附加数组的索引是堆数组的元素，附加数组的元素是堆数组的索引}</p>
<p><strong><u>这样做，可以通过元素找到【元素数组】的索引，通过这个索引根据【附加数组】找到该元素在堆数组中的索引，接着便可以在【堆数组】中找到对应的元素，可以在堆中对这个元素进行修改</u></strong></p>
<p>![image-20210811170130147](C:\Users\Mr Li\AppData\Roaming\Typora\typora-user-images\image-20210811170130147.png)</p>
<h4 id="3-3-1-最小索引优先队列"><a href="#3-3-1-最小索引优先队列" class="headerlink" title="3.3.1 最小索引优先队列"></a>3.3.1 最小索引优先队列</h4><h5 id="3-3-1-1API"><a href="#3-3-1-1API" class="headerlink" title="3.3.1.1API"></a>3.3.1.1API</h5><table>
<thead>
<tr>
<th>类名</th>
<th>IndexMinPriorityQueue&lt;&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>IndexMinPriorityQueue(int capacity)：创建容量为capacity的IndexMinPriorityQueue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 <br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值 <br>3.public int delMin():删除队列中最小的元素,并返回该元素关联的索引 <br>4.public void insert(int i,T t)：往队列中插入一个元素,并关联索引i <br>                            4.1 public void insert(T t)：方法重载，往队列中插入一个元素 <br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 <br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 <br>7.public int size():获取队列中元素的个数 <br>8.public boolean isEmpty():判断队列是否为空 <br>9.public boolean contains(int k):判断k对应的元素是否存在 <br>10.public void changeItem(int i, T t):把与索引i关联的元素修改为为t <br>11.public int minIndex():最小元素关联的索引 <br>12.public void delete(int i):删除索引i关联的元素</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组 <br>2.private int[] pq:保存每个元素在items数组中的索引，pq数组需要堆有序 <br>3.private int [] qp:保存qp的逆序，pq的值作为索引，pq的索引作为值 <br>4.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<h5 id="3-3-1-2-代码实现"><a href="#3-3-1-2-代码实现" class="headerlink" title="3.3.1.2 代码实现"></a>3.3.1.2 代码实现</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tree;</span><br><span class="line"></span><br><span class="line">public class IndexMinPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line">    private T[] items;</span><br><span class="line">    private int[] pq;</span><br><span class="line">    private int[] qp;</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    public IndexMinPriorityQueue(int capacity) &#123;</span><br><span class="line">        this.items = (T[]) new Comparable[capacity];</span><br><span class="line">        this.pq = new int[capacity + 1];</span><br><span class="line">        this.qp = new int[capacity];</span><br><span class="line">        N = 0;</span><br><span class="line">        for (int i= 0;i&lt; qp.length;i++)&#123;</span><br><span class="line">            qp[i]=-1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断堆中索引i处的元素是否小于索引j处的元素</span><br><span class="line">    private boolean less(int i, int j) &#123;</span><br><span class="line">        return items[pq[i]].compareTo(items[pq[j]])&lt;0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //交换堆中i索引和j索引处的值(注意治理并不是值),要同时更新qp中的值</span><br><span class="line">    private void exch(int i, int j) &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        temp = pq[i];</span><br><span class="line">        pq[i]=pq[j];</span><br><span class="line">        pq[j]=temp;</span><br><span class="line">        //更新qp的值</span><br><span class="line">        qp[pq[i]]=i;</span><br><span class="line">        qp[pq[j]]=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除队列中最小的元素,并返回该元素关联的索引</span><br><span class="line">    public int delMin() &#123;</span><br><span class="line">        int min = pq[1];</span><br><span class="line">        exch(1,N);</span><br><span class="line">        qp[pq[N]]=-1;</span><br><span class="line">        items[min] = null;</span><br><span class="line">        N--;</span><br><span class="line">        sink(1);</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //往队列中插入一个元素,并关联索引i</span><br><span class="line">    public void insert(int i, T t) &#123;</span><br><span class="line">        if (contains(i))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        items[i]=t;</span><br><span class="line">        pq[++N]=i;</span><br><span class="line">        //通过qp记录pq中的i</span><br><span class="line">        qp[i]=N;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span><br><span class="line">    private void swim(int k) &#123;</span><br><span class="line">        while (k&gt;1)&#123;</span><br><span class="line">            if (less(k,k/2))&#123;</span><br><span class="line">                exch(k,k/2);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            k=k/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span><br><span class="line">    private void sink(int k) &#123;</span><br><span class="line">        while (2*k&lt;=N)&#123;</span><br><span class="line">            int minIndex=2*k;</span><br><span class="line">            if (2*k+1&lt;=N &amp;&amp; less(2*k+1,2*k))&#123;</span><br><span class="line">                minIndex = 2*k+1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (less(minIndex,k))&#123;</span><br><span class="line">                exch(minIndex,k);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            k=minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取队列中元素的个数</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return N==0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断k对应的元素是否存在</span><br><span class="line">    public boolean contains(int k) &#123;</span><br><span class="line">        return qp[k]!=-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把与索引i关联的元素修改为为t</span><br><span class="line">    public void changeItem(int i, T t) &#123;</span><br><span class="line">        if (i&gt;N-1)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;索引有误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        items[i] = t;</span><br><span class="line">        //采用上浮或下沉算法实现堆的重新排序</span><br><span class="line">        int heapIndex = qp[i];</span><br><span class="line">            swim(heapIndex);</span><br><span class="line">            sink(heapIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最小元素关联的索引</span><br><span class="line">    public int minIndex() &#123;</span><br><span class="line">        return pq[1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除索引i关联的元素</span><br><span class="line">    public void delete(int i) &#123;</span><br><span class="line">        exch(qp[i],N);</span><br><span class="line">        qp[pq[N]]=-1;</span><br><span class="line">        items[i]=null;</span><br><span class="line">        N--;</span><br><span class="line">        swim(qp[i]);</span><br><span class="line">        sink(qp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自己代码：与老师相比不足的地方：附加数组没有初始化赋值，当末位置上的元素被删除时，附加数组对应索引上的值没有发生变化，有些不妥。另外，算法设计思想：**<u>每个方法实现时要同时考虑成员变量的变化，要做相应的修改，这样出现问题的可能就小点。</u>**例如，这个算法中，附加数组就是一个成员变量，用自己的思路，在交换堆数组中两个值之后，没有进行附加数组元素的变更，而是在swim和sink算法中统一变更，虽然在这个散发实现中可以，但是该思路不严密。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tree;</span><br><span class="line"></span><br><span class="line">public class IndexMinPriorityQueue01&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line">    private T[] items;</span><br><span class="line">    private int[] pq;</span><br><span class="line">    private int[] qp;</span><br><span class="line">    private int N;</span><br><span class="line"></span><br><span class="line">    public IndexMinPriorityQueue01(int capacity) &#123;</span><br><span class="line">        this.items = (T[]) new Comparable[capacity];</span><br><span class="line">        this.pq = new int[capacity + 1];</span><br><span class="line">        this.qp = new int[capacity];</span><br><span class="line">        N = 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断堆中索引i处的元素是否小于索引j处的元素</span><br><span class="line">    private boolean less(int i, int j) &#123;</span><br><span class="line">        return items[pq[i]].compareTo(items[pq[j]])&lt;0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //交换堆中i索引和j索引处的值(注意治理并不是值),要同时更新qp中的值</span><br><span class="line">    private void exch(int i, int j) &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        temp = pq[i];</span><br><span class="line">        pq[i]=pq[j];</span><br><span class="line">        pq[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除队列中最小的元素,并返回该元素关联的索引</span><br><span class="line">    public int delMin() &#123;</span><br><span class="line">        int min = pq[1];</span><br><span class="line">        exch(1,N);</span><br><span class="line">        items[min] = null;</span><br><span class="line">        N--;</span><br><span class="line">        sink(1);</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //往队列中插入一个元素,并关联索引i</span><br><span class="line">    public void insert(int i, T t) &#123;</span><br><span class="line">        if (contains(i))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        items[i]=t;</span><br><span class="line">        pq[++N]=i;</span><br><span class="line">        //通过qp记录pq中的i</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span><br><span class="line">    private void swim(int k) &#123;</span><br><span class="line">        while (k&gt;1)&#123;</span><br><span class="line">            if (less(k,k/2))&#123;</span><br><span class="line">                exch(k,k/2);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            k=k/2;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=1;i&lt;pq.length;i++)&#123;</span><br><span class="line">            qp[pq[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span><br><span class="line">    private void sink(int k) &#123;</span><br><span class="line">        while (2*k&lt;=N)&#123;</span><br><span class="line">            int minIndex=2*k;</span><br><span class="line">            if (2*k+1&lt;=N &amp;&amp; less(2*k+1,2*k))&#123;</span><br><span class="line">                minIndex = 2*k+1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (less(minIndex,k))&#123;</span><br><span class="line">                exch(minIndex,k);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            k=minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=1;i&lt;pq.length;i++)&#123;</span><br><span class="line">            qp[pq[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取队列中元素的个数</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return N==0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断k对应的元素是否存在</span><br><span class="line">    public boolean contains(int k) &#123;</span><br><span class="line">        if (k&lt;N &amp;&amp; items[k]!=null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把与索引i关联的元素修改为为t</span><br><span class="line">    public void changeItem(int i, T t) &#123;</span><br><span class="line">        if (i&gt;N-1)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;索引有误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        items[i] = t;</span><br><span class="line">        //采用上浮或下沉算法实现堆的重新排序</span><br><span class="line">        int heapIndex = qp[i];</span><br><span class="line">        swim(heapIndex);</span><br><span class="line">        sink(heapIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最小元素关联的索引</span><br><span class="line">    public int minIndex() &#123;</span><br><span class="line">        return pq[1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除索引i关联的元素</span><br><span class="line">    public void delete(int i) &#123;</span><br><span class="line">        exch(qp[i],N);</span><br><span class="line">        items[i]=null;</span><br><span class="line">        N--;</span><br><span class="line">        sink(qp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-2-最大索引优先队列"><a href="#3-3-2-最大索引优先队列" class="headerlink" title="3.3.2 最大索引优先队列"></a>3.3.2 最大索引优先队列</h4><p>类似索引最小优先队列</p>
<h1 id="四、红黑树、B树"><a href="#四、红黑树、B树" class="headerlink" title="四、红黑树、B树"></a>四、红黑树、B树</h1><p>见打印版</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Sun Moon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/01/29/first/%E6%A0%91/">http://example.com/2021/01/29/first/%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">SunMoon Space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/img-1608044174071f30505aaa23169cd5ccfb2a0cd4e1798.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/29/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83/"><img class="prev-cover" src="/img/img-1608044174071f30505aaa23169cd5ccfb2a0cd4e1798.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">华为机考</div></div></a></div><div class="next-post pull-right"><a href="/2020/01/29/%E5%8A%9B%E6%89%A3%E7%89%9B%E5%AE%A2/99%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.pn" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">恢复二叉树</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sun Moon</div><div class="author-info__description">Hi, welcome to my blog!</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sun-moon22"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/sun-moon22" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1476380153@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">一、二叉树入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E6%A0%91%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.1树定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E6%A0%91%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.2.</span> <span class="toc-text">1.2树术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.</span> <span class="toc-text">1.3二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.</span> <span class="toc-text">1.4二叉树的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E7%B1%BB"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">1.4.1二叉树节点类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%B1%BBAPI"><span class="toc-number">1.4.0.1.1.</span> <span class="toc-text">节点类API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.0.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%B1%BBAPI"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">1.4.2二叉树实现类API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#API"><span class="toc-number">1.4.0.2.1.</span> <span class="toc-text">API</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%80%9D%E6%83%B3"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">1.4.3二叉树增删改查思想</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95put%E6%80%9D%E6%83%B3"><span class="toc-number">1.4.0.3.1.</span> <span class="toc-text">插入方法put思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95get%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">1.4.0.3.2.</span> <span class="toc-text">查询方法get实现思想：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95delete%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">1.4.0.3.3.</span> <span class="toc-text">删除方法delete实现思想：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">1.4.4代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E5%85%B6%E4%BB%96%E4%BE%BF%E6%8D%B7%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 二叉树查找其他便捷方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84%E9%94%AE"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.5.1 查找二叉树中最小的键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E9%94%AE"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.5.2查找二叉树中最大的键</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 二叉树的基础遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.6.1 前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-1"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">1.6.2 中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-2"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">1.6.3 后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-3"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API-4"><span class="toc-number">1.7.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-3"><span class="toc-number">1.7.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">1.7.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 二叉树的最大深度问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B1%82"><span class="toc-number">1.8.1.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.8.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-5"><span class="toc-number">1.8.3.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">1.8.4.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.</span> <span class="toc-text">1.9 折纸问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%EF%BC%9A"><span class="toc-number">1.9.1.</span> <span class="toc-text">需求：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.9.2.</span> <span class="toc-text">分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">1.9.3.</span> <span class="toc-text">实现步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%BA%A6%E4%B8%BAN%E7%9A%84%E6%8A%98%E7%97%95%E6%A0%91%EF%BC%9A"><span class="toc-number">1.9.4.</span> <span class="toc-text">构建深度为N的折痕树：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">1.9.5.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9E%84%E9%80%A0%E6%B7%B1%E5%BA%A6%E4%B8%BAN-%E7%9A%84%E6%8A%98%E7%97%95%E6%A0%91%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.6.</span> <span class="toc-text">自己的构造深度为N 的折痕树的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A0%86Heap"><span class="toc-number">2.</span> <span class="toc-text">二、堆Heap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-1-gt-%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.0.1.</span> <span class="toc-text">&lt;1&gt;堆的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E5%A0%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">2.1堆的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E7%89%B9%E6%80%A7"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">2.2特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-API"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">2.3 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3"><span class="toc-number">2.0.1.4.</span> <span class="toc-text">2.4 实现思想</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-1-%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5"><span class="toc-number">2.0.1.4.1.</span> <span class="toc-text">2.4.1 元素插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-2%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4"><span class="toc-number">2.0.1.4.2.</span> <span class="toc-text">2.4.2最大元素删除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.0.1.5.</span> <span class="toc-text">2.5 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-1-gt-%E5%A0%86%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.2.</span> <span class="toc-text">&lt;1&gt;堆的排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E9%9C%80%E6%B1%82"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">2.6 需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">2.7 实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-1-%E6%9E%84%E9%80%A0%E5%A0%86"><span class="toc-number">2.0.2.2.1.</span> <span class="toc-text">2.7.1 构造堆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-2-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.2.2.2.</span> <span class="toc-text">2.7.2 堆排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-API"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">2.8 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.0.2.4.</span> <span class="toc-text">2.9 代码实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%A4%A7%E9%A1%B6%E5%A0%86%EF%BC%8C%E5%B0%8F%E9%A1%B6%E5%A0%86%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">三、优先队列（大顶堆，小顶堆）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E6%9C%80%E5%A4%A7%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%A4%A7%E5%AE%9A%E5%A0%86%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">3.1最大优先队列（大定堆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1API"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E6%9C%80%E5%B0%8F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%B0%8F%E9%A1%B6%E5%A0%86%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">3.2最小优先队列（小顶堆）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E7%89%B9%E6%80%A7%EF%BC%9A%EF%BC%88%E4%B8%8E%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%8F%8D%EF%BC%89"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">3.2.1 特性：（与堆的实现相反）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-API"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">3.2.2 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">3.2.3 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E7%B4%A2%E5%BC%95%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">3.3索引优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">3.3.1 最小索引优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-1API"><span class="toc-number">3.3.0.1.1.</span> <span class="toc-text">3.3.1.1API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.0.1.2.</span> <span class="toc-text">3.3.1.2 代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E6%9C%80%E5%A4%A7%E7%B4%A2%E5%BC%95%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">3.3.2 最大索引优先队列</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81B%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">四、红黑树、B树</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/20/hello-world/" title="Hello World"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/04/20/hello-world/" title="Hello World">Hello World</a><time datetime="2022-04-20T14:46:57.716Z" title="发表于 2022-04-20 22:46:57">2022-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/29/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83/" title="华为机考"><img src="/img/img-1608044174071f30505aaa23169cd5ccfb2a0cd4e1798.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="华为机考"/></a><div class="content"><a class="title" href="/2021/01/29/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83/" title="华为机考">华为机考</a><time datetime="2021-01-28T16:37:00.000Z" title="发表于 2021-01-29 00:37:00">2021-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/29/first/%E6%A0%91/" title="树"><img src="/img/img-1608044174071f30505aaa23169cd5ccfb2a0cd4e1798.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树"/></a><div class="content"><a class="title" href="/2021/01/29/first/%E6%A0%91/" title="树">树</a><time datetime="2021-01-28T16:37:00.000Z" title="发表于 2021-01-29 00:37:00">2021-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/01/29/%E5%8A%9B%E6%89%A3%E7%89%9B%E5%AE%A2/99%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" title="恢复二叉树"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.pn" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="恢复二叉树"/></a><div class="content"><a class="title" href="/2020/01/29/%E5%8A%9B%E6%89%A3%E7%89%9B%E5%AE%A2/99%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" title="恢复二叉树">恢复二叉树</a><time datetime="2020-01-28T16:37:00.000Z" title="发表于 2020-01-29 00:37:00">2020-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/01/29/%E5%8A%9B%E6%89%A3%E7%89%9B%E5%AE%A2/dfs%E3%80%81bfs/" title="dfs/dfs"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="dfs/dfs"/></a><div class="content"><a class="title" href="/2020/01/29/%E5%8A%9B%E6%89%A3%E7%89%9B%E5%AE%A2/dfs%E3%80%81bfs/" title="dfs/dfs">dfs/dfs</a><time datetime="2020-01-28T16:37:00.000Z" title="发表于 2020-01-29 00:37:00">2020-01-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Sun Moon</div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script async src="/js/weather.js"></script><div class="aplayer no-destroy" data-id="7389396649" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>